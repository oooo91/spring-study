package hello.core;

public class Memo {
    /*
    웬만한 프로토콜 - http
    HTML, TEXT, IMAGE, 영상, JSON, XML, 거의 모든 형태의 데이터 전송 가능, 서버 간의 데이터 요청/응답 등
    웹 서버 - HTTP를 기반으로 동작하는 서버 (서버에 저장된 정적 리소스 그대로 제공)
    정적 리소스 -  HTML, CSS, JS, 이미지, 영상 파일

    웹 어플리케이션 (WAS - Web application server) - HTTP 기반으로 동작 (웹 서버 기능 포함)
    특징 -> 프로그램을 코드를 실행해서 어플리케이션 로직 수행 (동적 HTML, HTTP API(JSON), 서블릿, JSP, 스프링 MVC가 WAS에서 동작한다.)
    예) TOMCAT

    웹 서버와 웹 어플리케이션 차이
    웹 서버 -> 정적 리소스 제공
    웹 어플리케이션 -> 어플리케이션 로직 수행
    그러나 모호하다. 웹 서버도 프로그램을 실행하는 기능을 포함하고, 웹 어플리케이션도 정적 리소스를 제공할 수 있다.
    자바는 서블릿 컨테이너를 제공하면 WAS라고 부른다. (서블릿 없이 자바코드를 실행하는 서버 프레임워크도 있어서 이 또한 모호하긴 하다.)

    옛날 웹 시스템 구성 - WAS, DB
    그러나 WAS가 너무 많은 역할을 담당하여 서버 과부하가 우려되는 현상이 발생했다.
    가장 비싼 어플리케이션 로직이 정적 리소스 때문에 수행이 어려워질 수 있다.
    WAS 장애 시 WAS에 접근이 불가능해진다. (오류 화면조차도 볼 수 없어진다.)

    현재의 웹 시스템 구성 - WEB, WAS, DB
    정적 리소스는 웹 서버가 처리하고,
    동적 리소스(어플리케이션 로직)는 WAS가 처리한다.
    효율적인 리소스 관리 - 정적 리소스가 많이 사용되면 WEB 서버 증설하면 되고, 동적 리소스가 많이 필요하면 WAS만 증설하면 된다.
    WAS 장애 시에도 오류 화면 접근이 가능해진다 - 정적 리소스만 제공하는 웹 서버는 잘 안 죽음 (그냥 파일 읽어다가 보여주는 서버라서)

    HTML FORM 데이터 전송 (POST 전송)
    데이터를 전송하면 -> 웹 브라우저가 요청 HTTP 메시지를 생성한다 -> 비즈니스 로직 수행 -> 서버에서 HTTP 응답 메시지를 생성한다
    근데 위를 직접 구현한다고 생각해보자
    1. 서버 TCP/IP 연결 대기, 소켓 연결
    2. HTTP 요청 메시지를 파싱해서 읽는다
    3. POST 방식, /save URL 인지한다
    4. Content-Type 확인한다
    5. HTTP 메시지 바디 내용 파싱한다.
    6. 비즈니스 로직 실행한다.
    7. HTTP 응답 메시지 생성한다. (HTTP 시작 라인 생성, HEADER 생성, 메시지 BODY 생성)
    8. TCP/IP에 응답 전달, 소켓 종료
    고작 저장하는 비즈니스 로직인데도 불구하고 앞단 뒷단으로 할 게 너무 많다 -> 비즈니스 로직을 제외한 모든 것들을 서블릿에 위임하자.

    서블릿 객체 (HelloServlet)
    @WebServlet(name = "helloServlet", urlPatterns = "/hello")
    pblic class HelloServlet extends HttpServlet {
        @Override
        protected void service(HttpServletRequest request, HttpServletResponse response) {
            //어플리케이션 로직
        }
    }
    urlPatterns(/hello)의 URL이 요청되면 서블릿 코드가 실행된다.
    HTTP 요청 정보를 편리하게 사용할 수 있는 REQUEST, HTTP 응답 정보를 편리하게 제공하는 RESPONSE
    덕분에 개발자는 편리하게 HTTP 스펙을 사용할 수 있다.

    흐름 정리
    1. 웹 브라우저 -> /hello 요청 -> 요청 기반으로 WAS 서버가 REQUEST, RESPONSE 객체를 새로 만들어 HelloServlet(서블릿 객체)을 호출한다.
    2. 개발자는 REQUEST 객체에서 요청 정보를 꺼내고, RESPONSE에 응답 정보를 담는다.
    3. WAS는 RESPONSE 기반으로 응답 메시지 만들어서 보내면 -> 웹 브라우저가 렌더링한다.

    WAS 안에는 서블릿 컨테이너가 있다
    서블릿을 지원하는 WAS 안에는 서블릿 컨테이너라는 게 있다.
    서블릿 객체(HelloServlet)를 직접 생성하지 않아도 이 컨테이너가 서블릿 객체를 생성, 호출, WAS가 종료될 때 서블릿을 함께 종료해주는 등 생명주기도 관리한다.

    서블릿 컨테이너
    톰캣처럼 서블릿을 지원하는 WAS를 서블릿 컨테이너라고 한다.
    서블릿 객체를 생성, 초기화, 호출, 종료하는 생명주기를 '관리'한다.
    싱글톤으로 관리한다. (공유 변수 사용 주의)
    JSP도 서블릿으로 변환되어서 사용된다.
    동시 요청을 위한 멀티 스레드 처리를 지원한다. (가장 큰 특징)

    스레드
    요청이 오면 WAS에 TCP 연결이 되고 -> 서블릿 객체를 누가 '호출'하지? -> 스레드가 호출한다.
    스레드는 한 번에 하나의 코드 라인만 수행할 수 있다.
    동시 처리가 필요하면 스레드를 추가로 생성한다.

    요청마다 스레드 생성 장단점
    장점
    동시 요청 처리가 가능하다.
    리소스(CPU, 메모리)가 허용될 때까지 처리 가능하다.
    하나의 스레드가 지연되도 나머지 스레드는 정상 동작한다.

    단점
    스레드는 생성 비용이 비싸다. (요청이 올 때마다 스레드를 생성하면 응답 속도가 늦어진다.)
    컨텍스트 스위칭 비용이 발생한다.
    스레드 생성에 제한이 없어서 요청이 많을 경우 CPU, 메모리 임계점을 넘어서 서버가 죽을 수 있다.

    단점 보완 방법 - WAS 안에 스레드 풀을 생성
    요청 오면 -> 스레드 풀에 (스레드 미리 풀어놔) 있는 스레드를 사용한다.
    스레드를 다 쓰면 스레드를 죽이는 게 아니라 다시 스레드 풀에 반납하도록 한다. (스레드를 생성/종료 가 아니라 대여 개념으로 사용한다.)
    이렇게 되면 스레드 풀보다 더 많은 요청이 동시에 왔을 때 -> 스레드 풀에 스레드가 없으니 -> 이때 대기시키거나(가능한 개수도 설정할 수 있다) 거절할 수 있다. (스레드 풀 장점)

    스레드 풀 정리 - 요청마다 스레드 생성의 단점 보완
    특징
    필요한 스레드를 스레드 풀에 보
    */
}





















