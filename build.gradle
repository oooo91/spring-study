/**
 1. 라이브러리 수동으로 주입하려면 버전 호환 문제가 많음
 id 'io.spring.dependency-management' version '1.1.0' 플러그인만 사용하면
 스프링부트가 알아서 스프링부트 버전에 최적화된 라이브러리 버전을 불러온다.
 dependency {} 에서 라이브러리 가져올 때 버전 생략이 가능한 이유다.
 스프링부트가 관리하지 않는 라이브러리도 있으니 이때는 버전을 생략하면 안 된다.
 (io.spring-boot 사이트에 dependency-versions에 들어가면 스프링부트가 지원하는 라이브러리 목록(BOM)을 볼 수 있다.)

 2. 웹 프로젝트 하나 만들 때 MVC, 톰캣, JSON 처리, LOG 등 다양한 라이브러리가 필요하다.
 개발자 입장에서는 그냥 한 줄로 웹 프로젝트 만들 때 필요로 하는 기본적인 라이브러리를 받고 싶다
 spring-boot-starter-web -> 웹 개발에 필요한 모든 라이브러리를 의존관계로 다 받을 수 있다.
 */

plugins {
    id 'java'
    id 'war'
}

group = 'hello'
version = '0.0.1-SNAPSHOT'
sourceCompatibility = '17'

repositories {
    mavenCentral()
}

dependencies {
    //서블릿 implementation 'jakarta.servlet:jakarta.servlet-api:6.0.0'

    //스프링 mvc 추가
    implementation 'org.springframework:spring-webmvc:6.0.4'

    //내장 톰캣 추가
    implementation 'org.apache.tomcat.embed:tomcat-embed-core:10.1.5'
}

tasks.named('test') {
    useJUnitPlatform()
}

/**
 * 이번에는 애플리케이션에 내장 톰캣을 라이브러리로 포함했다.
 * 이 코드를 어떻게 빌드하고 배포하는지 알아보자.
 * 자바의 main() 메서드를 실행하기 위해서는 jar 형식으로 빌드해야 한다.

 * 다음 위치에 jar 파일이 만들어졌을 것이다.
 build/libs/embed-0.0.1-SNAPSHOT.jar

 * jar 파일 실행
 * jar 파일이 있는 폴더로 이동한 후에 다음 명령어로 jar 파일을 실행해보자.
 * java -jar embed-0.0.1-SNAPSHOT.jar

 * 그런데 실행 결과를 보면 기대했던 내장 톰캣 서버가 실행되는 것이 아니라, 오류가 발생하는 것을 확인할 수 있다.
 *  오류 메시지를 잘 읽어보면 스프링 관련 클래스를 찾을 수 없다는 오류이다.

 * 무엇이 문제일까
 * JAR를 푼 결과를 보면 스프링 라이브러리나 내장 톰캣 라이브러리가 전혀 보이지 않는다. 라이브러리가 하나도 없는 순수 자바만 jar 로 만들어진 것이다.
 * 왜 이러나? jar 파일은 jar파일을 포함할 수 없다.

 * WAR와 다르게 JAR 파일은 내부에 라이브러리 역할을 하는 JAR 파일을 포함할 수 없다.
 * 포함한다고 해도 인식이 안된다. 이것이 JAR 파일 스펙의 한계이다.
 * 그렇다고 WAR를 사용할 수 도 없다. WAR는 웹 애플리케이션 서버(WAS) 위에서만 실행할 수 있다.

 * 대안으로는 라이브러리 jar 파일을 모두 구해서 MANIFEST 파일에 해당 경로를 적어주면 인식이 되지만 매우 번거롭고,
 * Jar 파일안에 Jar 파일을 포함할 수 없기 때문에 라이브러리 역할을 하는 jar 파일도 항상 함께 가지고 다녀야 한다.
 * 이 방법은 권장하기 않기 때문에 따로 설명하지 않는다.

 * 대안으로는 fat jar 또는 uber jar 라고 불리는 방법이다.
 * Jar 안에는 Jar를 포함할 수 없다. 하지만 클래스는 얼마든지 포함할 수 있다.
 * 라이브러리에 사용되는 jar 를 풀면 class 들이 나온다. 이 class 를 뽑아서 새로 만드는 jar 에 포함하는 것이다.
 * 이렇게 하면 수 많은 라이브러리에서 나오는 class 때문에 뚱뚱한(fat) jar 가 탄생한다. 그래서 Fat Jar 라고 부르는 것이다
 */
task buildJar(type: Jar) {
    manifest {
        attributes 'Main-Class': 'hello.embed.EmbedTomcatSpringMain'
    }
    with jar
}

//Fat jar 생성
task buildFatJar(type: Jar) {
    manifest {
        attributes 'Main-Class': 'hello.embed.EmbedTomcatSpringMain' //실행 위치
    }
    duplicatesStrategy = DuplicatesStrategy.WARN
    from {
        configurations.runtimeClasspath.collect {
            it.isDirectory() ? it :
                    zipTree(it)
        }
    }
    with jar
}

/**
 * Fat Jar 정리

 * Fat Jar의 장점
 * Fat Jar 덕분에 하나의 배포 jar 파일에 필요한 라이브러리들을 내장할 수 있게 되었다.
 * 내장 톰캣 라이브러리를 jar 내부에 내장할 수 있게 되었다.
 * 덕분에 하나의 jar 파일로 배포부터, 웹 서버 설치+실행까지 모든 것을 단순화 할 수 있다.

 * 이전에 살펴보았던 WAR를 외부 서버에 배포하는 방식의 단점을 다시 확인해보자.
 * WAR 단점과 해결
 * 1. 톰캣 같은 WAS를 별도로 설치해야 한다.
 * 해결: WAS를 별도로 설치하지 않아도 된다. 톰캣 같은 WAS가 라이브러리로 jar 내부에 포함되어 있다.

 * 2. 개발 환경 설정이 복잡하다.
 * 단순한 자바라면 별도의 설정을 고민하지 않고, main() 메서드만 실행하면 된다.
 * 그러나 웹 애플리케이션은 WAS를 연동하기 위한 복잡한 설정이 들어간다.
 * 해결: IDE에 복잡한 WAS 설정이 필요하지 않다. 단순히 main() 메서드만 실행하면 된다.

 * 3. 배포 과정이 복잡하다. WAR를 만들고 이것을 또 WAS에 전달해서 배포해야 한다.
 * 해결: 배포 과정이 단순하다. JAR를 만들고 이것을 원하는 위치에서 실행만 하면 된다.

 * 4. 톰캣의 버전을 업데이트 하려면 톰캣을 다시 설치해야 한다.
 * 해결: gradle에서 내장 톰캣 라이브러리 버전만 변경하고 빌드 후 실행하면 된다.

 * Fat Jar의 단점 -> 스프링 부트가 해결
 * Fat Jar는 완벽해 보이지만 몇가지 단점을 여전히 포함하고 있다.
 * 1. 어떤 라이브러리가 포함되어 있는지 확인하기 어렵다.
 * 모두 class 로 풀려있으니 어떤 라이브러리가 사용되고 있는지 추적하기 어렵다.
 * 2. 파일명 중복을 해결할 수 없다.
 * 클래스나 리소스 명이 같은 경우 하나를 포기해야 한다. 이것은 심각한 문제를 발생한다.
 * 예를 들어서 서블릿 컨테이너 초기화에서 학습한 부분을 떠올려 보자.
 * META-INF/services/jakarta.servlet.ServletContainerInitializer 이 파일이 여러 라이브러리( jar )에 있을 수 있다.
 * A 라이브러리와 B 라이브러리 둘다 해당 파일을 사용해서 서블릿 컨테이너 초기화를 시도한다.
 * 둘 다 해당 파일을 jar 안에 포함한다.
 * Fat Jar 를 만들면 파일명이 같으므로 A , B 라이브러리가 둘다 가지고 있는 파일 중에 하나의 파일만 선택된다.
 * 결과적으로 나머지 하나는 포함되지 않으므로 정상 동작하지 않는다.
 */