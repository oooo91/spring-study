package hello.core;

public class MVCMemo {
    /*
    웬만한 프로토콜 - http
    HTML, TEXT, IMAGE, 영상, JSON, XML, 거의 모든 형태의 데이터 전송 가능, 서버 간의 데이터 요청/응답 등
    웹 서버 - HTTP를 기반으로 동작하는 서버 (서버에 저장된 정적 리소스 그대로 제공)
    정적 리소스 -  HTML, CSS, JS, 이미지, 영상 파일

    웹 어플리케이션 (WAS - Web application server) - HTTP 기반으로 동작 (웹 서버 기능 포함)
    특징 -> 프로그램을 코드를 실행해서 어플리케이션 로직 수행 (동적 HTML, HTTP API(JSON), 서블릿, JSP, 스프링 MVC가 WAS에서 동작한다.)
    예) TOMCAT

    웹 서버와 웹 어플리케이션 차이
    웹 서버 -> 정적 리소스 제공
    웹 어플리케이션 -> 어플리케이션 로직 수행
    그러나 모호하다. 웹 서버도 프로그램을 실행하는 기능을 포함하고, 웹 어플리케이션도 정적 리소스를 제공할 수 있다.
    자바는 서블릿 컨테이너를 제공하면 WAS라고 부른다. (서블릿 없이 자바코드를 실행하는 서버 프레임워크도 있어서 이 또한 모호하긴 하다.)

    옛날 웹 시스템 구성 - WAS, DB
    그러나 WAS가 너무 많은 역할을 담당하여 서버 과부하가 우려되는 현상이 발생했다.
    가장 비싼 어플리케이션 로직이 정적 리소스 때문에 수행이 어려워질 수 있다.
    WAS 장애 시 WAS에 접근이 불가능해진다. (오류 화면조차도 볼 수 없어진다.)

    현재의 웹 시스템 구성 - WEB, WAS, DB
    정적 리소스는 웹 서버가 처리하고,
    동적 리소스(어플리케이션 로직)는 WAS가 처리한다.
    효율적인 리소스 관리 - 정적 리소스가 많이 사용되면 WEB 서버 증설하면 되고, 동적 리소스가 많이 필요하면 WAS만 증설하면 된다.
    WAS 장애 시에도 오류 화면 접근이 가능해진다 - 정적 리소스만 제공하는 웹 서버는 잘 안 죽음 (그냥 파일 읽어다가 보여주는 서버라서)

    HTML FORM 데이터 전송 (POST 전송)
    데이터를 전송하면 -> 웹 브라우저가 요청 HTTP 메시지를 생성한다 -> 비즈니스 로직 수행 -> 서버에서 HTTP 응답 메시지를 생성한다
    근데 위를 직접 구현한다고 생각해보자
    1. 서버 TCP/IP 연결 대기, 소켓 연결
    2. HTTP 요청 메시지를 파싱해서 읽는다
    3. POST 방식, /save URL 인지한다
    4. Content-Type 확인한다
    5. HTTP 메시지 바디 내용 파싱한다.
    6. 비즈니스 로직 실행한다.
    7. HTTP 응답 메시지 생성한다. (HTTP 시작 라인 생성, HEADER 생성, 메시지 BODY 생성)
    8. TCP/IP에 응답 전달, 소켓 종료
    고작 저장하는 비즈니스 로직인데도 불구하고 앞단 뒷단으로 할 게 너무 많다 -> 비즈니스 로직을 제외한 모든 것들을 서블릿에 위임하자.

    서블릿 객체 (HelloServlet)
    @WebServlet(name = "helloServlet", urlPatterns = "/hello")
    pblic class HelloServlet extends HttpServlet {
        @Override
        protected void service(HttpServletRequest request, HttpServletResponse response) {
            //어플리케이션 로직
        }
    }
    urlPatterns(/hello)의 URL이 요청되면 서블릿 코드가 실행된다.
    HTTP 요청 정보를 편리하게 사용할 수 있는 REQUEST, HTTP 응답 정보를 편리하게 제공하는 RESPONSE
    덕분에 개발자는 편리하게 HTTP 스펙을 사용할 수 있다.

    흐름 정리
    1. 웹 브라우저 -> /hello 요청 -> 요청 기반으로 WAS 서버가 REQUEST, RESPONSE 객체를 새로 만들어 HelloServlet(서블릿 객체)을 호출한다.
    2. 개발자는 REQUEST 객체에서 요청 정보를 꺼내고, RESPONSE에 응답 정보를 담는다.
    3. WAS는 RESPONSE 기반으로 응답 메시지 만들어서 보내면 -> 웹 브라우저가 렌더링한다.

    WAS 안에는 서블릿 컨테이너가 있다
    서블릿을 지원하는 WAS 안에는 서블릿 컨테이너라는 게 있다.
    서블릿 객체(HelloServlet)를 직접 생성하지 않아도 이 컨테이너가 서블릿 객체를 생성, 호출, WAS가 종료될 때 서블릿을 함께 종료해주는 등 생명주기도 관리한다.

    서블릿 컨테이너
    톰캣처럼 서블릿을 지원하는 WAS를 서블릿 컨테이너라고 한다.
    서블릿 객체를 생성, 초기화, 호출, 종료하는 생명주기를 '관리'한다.
    싱글톤으로 관리한다. (공유 변수 사용 주의)
    JSP도 서블릿으로 변환되어서 사용된다.
    동시 요청을 위한 멀티 스레드 처리를 지원한다. (가장 큰 특징)

    WAS는 멀티 스레드를 지원함
    멀티 스레드에 대한 부분은 WAS가 처리한다.
    개발자가 멀티 스레드 관련 코드를 신경쓰지 않아도 된다.
    개발자는 마치 싱글 스레드 프로그래밍을 하듯이 편리하게 소스 코드를 개발하면 된다.
    MAX값 설정하면 풀을 생성하고 관리하고 스레드 처리는 WAS가 다 해준다.
    대신 멀티 스레드 환경이므로 싱글톤 객체 (서블릿, 스프링 빈)는 주의해서 사용하자.

    스레드
    요청이 오면 WAS에 TCP 연결이 되고 -> 서블릿 객체를 누가 '호출'하지? -> 스레드가 호출한다.
    스레드는 한 번에 하나의 코드 라인만 수행할 수 있다.
    동시 처리가 필요하면 스레드를 추가로 생성한다.

    요청마다 스레드 생성 장단점
    장점
    동시 요청 처리가 가능하다.
    리소스(CPU, 메모리)가 허용될 때까지 처리 가능하다.
    하나의 스레드가 지연되도 나머지 스레드는 정상 동작한다.

    단점
    스레드는 생성 비용이 비싸다. (요청이 올 때마다 스레드를 생성하면 응답 속도가 늦어진다.)
    컨텍스트 스위칭 비용이 발생한다.
    스레드 생성에 제한이 없어서 요청이 많을 경우 CPU, 메모리 임계점을 넘어서 서버가 죽을 수 있다.

    단점 보완 방법 - WAS 안에 스레드 풀을 생성
    요청 오면 -> 스레드 풀에 (스레드 미리 풀어놔) 있는 스레드를 사용한다.
    스레드를 다 쓰면 스레드를 죽이는 게 아니라 다시 스레드 풀에 반납하도록 한다. (스레드를 생성/종료 가 아니라 대여 개념으로 사용한다.)
    이렇게 되면 스레드 풀보다 더 많은 요청이 동시에 왔을 때 -> 스레드 풀에 스레드가 없으니 -> 이때 대기시키거나(가능한 개수도 설정할 수 있다) 거절할 수 있다. (스레드 풀 장점)

    스레드 풀 정리 - 요청마다 스레드 생성의 단점 보완
    특징
    필요한 스레드를 스레드 풀에 보관하고 관리한다.
    스레드 풀에 생성 가능한 스레드의 최대치를 관리한다. 톰캣은 최대 200개 기본 설정 (변경 가능)

    사용
    스레드가 필요하면 이미 생성되어 있는 스레드를 스레드 풀에서 꺼내어 사용한다.
    사용을 종료하면 스레드 풀에 해당 스레드를 '반납'한다.
    최대 스레드가 모두 사용 중이라 스레드 풀에 스레드가 없으면 -> 요청을 거절하거나 특정 숫자만큼 대기하도록 설정할 수 있다.

    장점
    스레드가 미리 생성되어 있으므로 스레드를 생성하고 종료하는 비용(CPU)이 절약되고 응답 시간이 빠르다.
    생성 가능한 스레드의 최대치가 있으므로 너무 많은 요청이 들어와도 기존 요청은 안전하게 처리할 수 있다.

    실무 팁 (성능 튜닝)
    WAS의 주요 튜닝 포인트는 -> 최대 스레드 (MAX THREAD) 수를 어느 정도 설정해야할까
    자, CPU 사용량이 얼마지? -> 5% ... -> MAX THREAD 자체를 너무 작게 잡으면 CPU는 적은 스레드 수만 처리되고 나머지는 대기되거나 거절당한다.
    CPU를 5 10%밖에 못 쓴다? -> 수치스러운 수치 (WOW) -> 설정만 좀 잘해도 못해도 50%는 사용할 수 있다.
    값을 너무 높게 설정한다면? -> CPU, 메모리 리소스가 임계점 초과로 서버가 다운된다. (10000갸의 요청을 다 처리한다면 서버는 죽는다.)
    따라서 적정값을 찾는 것이 중요하다.

    장애 발생 시?
    클라우드면? (서비스라면) 일단 서버부터 늘리고 (서비스부터 살아야하니까) 이후에 튜닝
    클라우드가 아니면 평상시에 튜닝

    어떻게 적정 숫자를 찾나요?
    어플리케이션 로직의 복잡도, CPU, 메모리, I/O 리소스 상황에 따라 모두 다르다.
    트래픽이 있는 서비스라면 성능 테스트를 하자. (최대한 실제 서비스와 유사하게 성능 테스트 시도하기. 툴 : 아파치 ab, 제이미터, nGrinder)
    트래픽을 왜 이렇게 못 받지? -> 병목 포인트 찾아서 튜닝 등

    정적 리소스
    고정된 HTML 파일, CSS, JS, 이미지, 영상 등을 제공
    주로 웹 브라우저가 요청

    HTML 페이지
    WAS가 비즈니스 로직 수행 후 동적으로 필요한 HTML 파일을 생성해서 (뷰 템플릿 : JSP, 타임리프) 전달한다.
    웹 브라우저 : HTML 해석한다.

    HTTP API
    HTML이 아니라 데이터를 전달하는 개념이다.
    주로 JSON 형식을 사용한다.
    JSON이 요면 브라우저는 HTML 해석하는데 JSON을 해석하겠냐? -> JS가 해석하여 브라우저에 뿌릴 수 있다.
    이처럼 웹 클라이언트 TO 서버뿐 아니라 앱 클라이언트 TO 서버, 서버 TO 서버에서 HTTP API가 쓰인다.

    정적 리소스, 동적 리소스 어떻게 전달할래? HTTP API 어떻게 정의할래? 를 고민해야한다.

    서버 사이드 렌더링 - SSR
    서버에서 최종적으로 동적 HTML을 생성하여 클라이언트에 전달 (브라우저는 뿌려주기만 한다.)
    주로 정적인 화면에서 사용된다. JSP, 타임리프
    SSR을 사용해도 JS를 사용해서 일부 변경 가능하다.

    클라이언트 사이드 렌더링 - CSR
    HTML 결과를 자바스크립트를 사용해 웹 브라우저에서 동적으로 HTML을 생성한 후 적용한다.
    자바스크립트가 동적으로 HTML을 만든다. 웹 환경을 마치 앱처럼 필요한 부분을 변경할 수 있다.
    React, Vue.js가 사용된다.

    어디까지 알아야 하나요?
    백엔드 개발자의 웹 프론트엔드 기술 학습은 옵션이다.
    백엔드 개발자는 서버, DB, 인프라 등 수많은 백엔드 기술을 공부해야한다.
    */
}





















